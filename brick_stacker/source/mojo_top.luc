module mojo_top (
  input clk,              // 50MHz clock
  input rst_n,            // reset button (active low)
  output led [8],         // 8 user controllable LEDs
  input cclk,             // configuration clock, AVR ready when high
  output spi_miso,        // AVR SPI MISO
  input spi_ss,           // AVR SPI Slave Select
  input spi_mosi,         // AVR SPI MOSI
  input spi_sck,          // AVR SPI Clock
  output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
  input avr_tx,           // AVR TX (FPGA RX)
  output avr_rx,          // AVR RX (FPGA TX)
  input avr_rx_busy,      // AVR RX buffer full
  input io_button[5],
  output a[16],
  output c[16]
  ) {

    sig rst;              // reset signal
    sig led_pattern[16][16];  //sig to store led patterns for all 16 rows
    var i;

    .clk(clk) {
      // The reset conditioner is used to synchronize the reset signal to the FPGA
      // clock. This ensures the entire FPGA comes out of reset at the same time.
      reset_conditioner reset_cond;
      .rst(rst){
        led_test ledMtest;
        led_matrix ledM;
        counter clocky(#SIZE(1),#DIV(16));  //must be the same as led_Matrix DIV
        dff brick_pos[16](#INIT(h0007));    //tracks position of brick
        dff direction[1](#INIT(0));         //sets direction to shift
        dff brick_level[4](#INIT(0));
        fsm bricky (#INIT(ONE)) = {ONE,TWO, THREE, FOUR};
      }
    }

    .clk(clocky.value) {
      .rst(rst){
        counter posClock(#SIZE(1),#DIV(5));  //dividing the led scan clock by 2^3

      }
    }
    //  always {
    //   //initializing the led pattern to draw a 3x3 cube at the bottom
    //   for (i = 0; i < led_pattern.WIDTH[0]; i++) {
     //
    //     if(i == 0 || i == 1 || i == 2)
    //       led_pattern[i] = h0380;
    //     else
    //       led_pattern[i] = h0000;
    //   }
     //
    //   case(posClock.value) {
    //     0:
    //       led_pattern[0] = h0380;
    //       led_pattern[1] = h0380;
    //       led_pattern[2] = h0380;
    //     1:
    //       led_pattern[0] = h0007;
    //       led_pattern[1] = h0007;
    //       led_pattern[2] = h0007;
    //   }
     //
    //   ledM.pattern = led_pattern;
    //  }

    always {
      reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset

      //led = h00;              // turn LEDs off
      spi_miso = bz;          // not using SPI
      spi_channel = bzzzz;    // not using flags
      avr_rx = bz;            // not using serial port

      a = ledM.a;             //set anode pins to output from ledM module
      c = ledM.c;             //set cathode pins to output from ledM module

      case(bricky.q) {
        bricky.ONE:
          if(posClock.value == 1) {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.TWO;
          }
          else {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.ONE;
          }

          direction.d = direction.q;
          brick_level.d = brick_level.q;
        bricky.TWO:
          case(direction.q) {
            0:
              if(brick_pos.q != hE000) {
                brick_pos.d = brick_pos.q << 1;
                direction.d = direction.q;
              }
              else {
                brick_pos.d = brick_pos.q;
                direction.d = 1;
              }
            1:
              if(brick_pos.q != h0007) {
                brick_pos.d = brick_pos.q >> 1;
                direction.d = direction.q;
              }
              else {
                brick_pos.d = brick_pos.q;
                direction.d = 0;
              }
          }

          brick_level.d = brick_level.q;
          bricky.d = bricky.THREE;

        bricky.THREE:
          if(posClock.value == 1) {
            bricky.d = bricky.THREE;
            brick_level.d = brick_level.q;
          }
          else {
            if(brick_level.q != 12) {
              brick_level.d = brick_level.q + 3;
            }
            else {
              brick_level.d = 0;
            }
            bricky.d = bricky.ONE;
          }
          direction.d = direction.q;
      }


      for (i = 0; i < led_pattern.WIDTH[0]; i++) {

//        if(i == 0 || i == 1 || i == 2)
//          led_pattern[i] = h0380;
//        else
          led_pattern[i] = h0000;
      }

      led_pattern[brick_level.q] = brick_pos.q;
      led_pattern[brick_level.q+1] = brick_pos.q;
      led_pattern[brick_level.q+2] = brick_pos.q;

      led = direction.q;
      ledM.pattern = led_pattern;
     }
  }
