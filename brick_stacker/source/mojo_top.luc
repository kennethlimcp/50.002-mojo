module mojo_top (
  input clk,              // 50MHz clock
  input rst_n,            // reset button (active low)
  output led [8],         // 8 user controllable LEDs
  input cclk,             // configuration clock, AVR ready when high
  output spi_miso,        // AVR SPI MISO
  input spi_ss,           // AVR SPI Slave Select
  input spi_mosi,         // AVR SPI MOSI
  input spi_sck,          // AVR SPI Clock
  output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
  input avr_tx,           // AVR TX (FPGA RX)
  output avr_rx,          // AVR RX (FPGA TX)
  input avr_rx_busy,      // AVR RX buffer full
  input io_button[5],
  output a[16],
  output c[16]
  ) {

    sig rst;              // reset signal

    .clk(clk) {
      // The reset conditioner is used to synchronize the reset signal to the FPGA
      // clock. This ensures the entire FPGA comes out of reset at the same time.
      reset_conditioner reset_cond;
      .rst(rst){
        led_test ledM;
      }
    }

    always {
      reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset

      led = 8h00;             // turn LEDs off
      spi_miso = bz;          // not using SPI
      spi_channel = bzzzz;    // not using flags
      avr_rx = bz;            // not using serial port

      a = ledM.a;
      c = ledM.c;
      // a = h0000;
      // c = hFFFF;
      //
      // state.d=state.q;
      //
      // case(state.q){
      //   state.ONE:
      //
      //   a = h0000;
      //   c = h00FF;
      //
      //   aSignal.d = h0000;
      //   cSignal.d = hFFFF;
      //
      //   state.d = state.TWO;
      //
      //   //switch cathode selection
      //   state.TWO:
      //
      //   if(cSignal.q == hFFFF) {
      //     cSignal.d = hFFFE;
      //   }
      //   else if(cSignal.q == h7FFF) {
      //     cSignal.d = hFFFE;
      //   }
      //   else {
      //     cSignal.d = (cSignal.q << 1) + 1;
      //   }
      //
      //   // case(cSignal.q) {
      //   //   hFF:
      //   //     cSignal.d = hFE;
      //   //   hFE:
      //   //     cSignal.d = hFD;
      //   //   hFD:
      //   //     cSignal.d = hFB;
      //   //   hFB:
      //   //     cSignal.d = hF7;
      //   //   hF7:
      //   //     cSignal.d = hEF;
      //   //   hEF:
      //   //     cSignal.d = hDF;
      //   //   hDF:
      //   //     cSignal.d = hBF;
      //   //   hBF:
      //   //     cSignal.d = h7F;
      //   //   h7F:
      //   //     cSignal.d = hFE;
      //   // }
      //
      //   a = aSignal.q;
      //   c = cSignal.q;
      //   state.d=state.THREE;
      //
      //   //switch anode selection
      //   state.THREE:
      //
      //   if(aSignal.q == h0000) {
      //     aSignal.d = h0001;
      //     state.d = state.THREE;
      //   }
      //   else if(aSignal.q == h8000) {
      //     aSignal.d = h0001;
      //     state.d = state.TWO;
      //   }
      //   else {
      //     aSignal.d = (aSignal.q << 1);
      //     state.d = state.THREE;
      //   }
      //   //  case(aSignal.q) {
      //   //   h00:
      //   //     aSignal.d = h01;
      //   //     state.d=state.THREE;
      //   //   h01:
      //   //     aSignal.d = h02;
      //   //     state.d=state.THREE;
      //   //   h02:
      //   //     aSignal.d = h04;
      //   //     state.d=state.THREE;
      //   //   h04:
      //   //     aSignal.d = h08;
      //   //     state.d=state.THREE;
      //   //   h08:
      //   //     aSignal.d = h10;
      //   //     state.d=state.THREE;
      //   //   h10:
      //   //     aSignal.d = h20;
      //   //     state.d=state.THREE;
      //   //   h20:
      //   //     aSignal.d = h40;
      //   //     state.d=state.THREE;
      //   //   h40:
      //   //     aSignal.d = h80;
      //   //     state.d=state.THREE;
      //   //   h80:
      //   //     aSignal.d = h01;
      //   //     state.d=state.TWO;
      //   // }
      //
      //   a = aSignal.q;
      //   c = cSignal.q;
      // }
    }
  }
