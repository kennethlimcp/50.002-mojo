module mojo_top (
  input clk,              // 50MHz clock
  input rst_n,            // reset button (active low)
  output led [8],         // 8 user controllable LEDs
  input cclk,             // configuration clock, AVR ready when high
  output spi_miso,        // AVR SPI MISO
  input spi_ss,           // AVR SPI Slave Select
  input spi_mosi,         // AVR SPI MOSI
  input spi_sck,          // AVR SPI Clock
  output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
  input avr_tx,           // AVR TX (FPGA RX)
  output avr_rx,          // AVR RX (FPGA TX)
  input avr_rx_busy,      // AVR RX buffer full
  input io_button[5],
  output a[16],
  output c[16]
  ) {

    sig rst;              // reset signal
    sig led_pattern[16][16];  //sig to store led patterns for all 16 rows
    var i;

    .clk(clk) {
      // The reset conditioner is used to synchronize the reset signal to the FPGA
      // clock. This ensures the entire FPGA comes out of reset at the same time.
      reset_conditioner reset_cond;
      .rst(rst){
        led_test ledMtest;
        led_matrix ledM;
        counter clocky(#SIZE(1),#DIV(16));  //smaller the faster the refresh
        dff brick_pos[16](#INIT(h0007));
        fsm bricky (#INIT(ONE)) = {ONE,TWO, THREE};
      }
    }

    //this is not in use but left here for easy access when needed
    .clk(clocky.value) {
      .rst(rst){
        counter posClock(#SIZE(1),#DIV(7));  //smaller the faster the refresh

      }
    }
    //  always {
    //   //initializing the led pattern to draw a 3x3 cube at the bottom
    //   for (i = 0; i < led_pattern.WIDTH[0]; i++) {
     //
    //     if(i == 0 || i == 1 || i == 2)
    //       led_pattern[i] = h0380;
    //     else
    //       led_pattern[i] = h0000;
    //   }
     //
    //   case(posClock.value) {
    //     0:
    //       led_pattern[0] = h0380;
    //       led_pattern[1] = h0380;
    //       led_pattern[2] = h0380;
    //     1:
    //       led_pattern[0] = h0007;
    //       led_pattern[1] = h0007;
    //       led_pattern[2] = h0007;
    //   }
     //
    //   ledM.pattern = led_pattern;
    //  }

    always {
      reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset

      //led = h00;              // turn LEDs off
      spi_miso = bz;          // not using SPI
      spi_channel = bzzzz;    // not using flags
      avr_rx = bz;            // not using serial port

      a = ledM.a;             //set anode pins to output from ledM module
      c = ledM.c;             //set cathode pins to output from ledM module

      //initializing the led pattern to draw a 3x3 cube at the bottom

      case(bricky.q) {
        bricky.ONE:
          if(posClock.value == 1) {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.TWO;
          }
          else {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.ONE;
          }
        bricky.TWO:
          if(brick_pos.q != hE000) {
            brick_pos.d = brick_pos.q << 1;
          }
          else {
            brick_pos.d = h0007;
          }
          bricky.d = bricky.THREE;
        bricky.THREE:
          if(posClock.value == 1) {
            bricky.d = bricky.THREE;
          }
          else {
            bricky.d = bricky.ONE;
          }

      }


      led_pattern[0] = brick_pos.q;
      led_pattern[1] = brick_pos.q;
      led_pattern[2] = brick_pos.q;
      for (i = 3; i < led_pattern.WIDTH[0]; i++) {

        if(i == 0 || i == 1 || i == 2)
          led_pattern[i] = h0380;
        else
          led_pattern[i] = h0000;
      }

      led = brick_pos.q;
      ledM.pattern = led_pattern;
     }
  }
