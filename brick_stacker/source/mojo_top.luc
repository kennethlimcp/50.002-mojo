module mojo_top (
  input clk,              // 50MHz clock
  input rst_n,            // reset button (active low)
  output led [8],         // 8 user controllable LEDs
  input cclk,             // configuration clock, AVR ready when high
  output spi_miso,        // AVR SPI MISO
  input spi_ss,           // AVR SPI Slave Select
  input spi_mosi,         // AVR SPI MOSI
  input spi_sck,          // AVR SPI Clock
  output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
  input avr_tx,           // AVR TX (FPGA RX)
  output avr_rx,          // AVR RX (FPGA TX)
  input avr_rx_busy,      // AVR RX buffer full
  input io_button[5],
  output a[16],
  output c[16],
  input button
  ) {

    sig rst;              // reset signal
    sig led_pattern[16][16];  //sig to store led patterns for all 16 rows
    var i;

    .clk(clk) {
      // The reset conditioner is used to synchronize the reset signal to the FPGA
      // clock. This ensures the entire FPGA comes out of reset at the same time.
      reset_conditioner reset_cond;
      button_conditioner butt;
      edge_detector butt_edge(#RISE(0),#FALL(1));
      simple_ram led_ram(#SIZE(16),#DEPTH(16));

      .rst(rst){
        led_test ledMtest;
        led_matrix ledM;
        counter clocky(#SIZE(1),#DIV(16));  //must be the same as led_Matrix DIV
        dff brick_pos[16](#INIT(h0007));    //tracks position of brick
        dff direction[1](#INIT(0));         //sets direction to shift
        dff brick_level[4](#INIT(0));       //tells you which level is the brick moving on
        dff previous_state[2](#INIT(0));     //remembers the previous_state for button irq
        dff j[4](#INIT(0));
        fsm bricky (#INIT(INIT)) = {INIT, ONE, TWO, THREE, FOUR};

        dff edge_detected[1](#INIT(0));
      }
    }

    .clk(clocky.value) {
      .rst(rst){
        counter posClock(#SIZE(1),#DIV(3));  //dividing the led scan clock by 2^3

      }
    }
    //  always {
    //   //initializing the led pattern to draw a 3x3 cube at the bottom
    //   for (i = 0; i < led_pattern.WIDTH[0]; i++) {
    //
    //     if(i == 0 || i == 1 || i == 2)
    //       led_pattern[i] = h0380;
    //     else
    //       led_pattern[i] = h0000;
    //   }
    //
    //   case(posClock.value) {
    //     0:
    //       led_pattern[0] = h0380;
    //       led_pattern[1] = h0380;
    //       led_pattern[2] = h0380;
    //     1:
    //       led_pattern[0] = h0007;
    //       led_pattern[1] = h0007;
    //       led_pattern[2] = h0007;
    //   }
    //
    //   ledM.pattern = led_pattern;
    //  }

    always {
      reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset

      butt.in = button;
      butt_edge.in = butt.out;

      led_ram.address = 0; // use brick_level as the address
      led_ram.write_data = h0000;      // don't care
      led_ram.write_en = 0;            // read by default

      led = led_ram.read_data;
      spi_miso = bz;          // not using SPI
      spi_channel = bzzzz;    // not using flags
      avr_rx = bz;            // not using serial port

      a = ledM.a;             //set anode pins to output from ledM module
      c = ledM.c;             //set cathode pins to output from ledM module
      j.d = h0;

      for (i = 0; i < led_pattern.WIDTH[0]; i++) {
        led_pattern[i] = h0000;
      }

      case(bricky.q) {
        bricky.INIT:
          if(j.q != 15) {
            led_ram.address = j.q;
            led_ram.write_data = h0007;
            led_ram.write_en = 1;
            j.d = j.q + 1;
            bricky.d = bricky.INIT;
          }
          else {
            led_ram.write_en = 0;
            led_ram.address = 0;
            bricky.d = bricky.ONE;
          }

        bricky.ONE:
        if(posClock.value == 1) {
          brick_pos.d = brick_pos.q;
          bricky.d = bricky.TWO;
        }
        else {
          brick_pos.d = brick_pos.q;
          bricky.d = bricky.ONE;
        }

        if(butt_edge.out) {
          bricky.d = bricky.FOUR;
        }

        led_ram.write_data = brick_pos.q;
        led_ram.write_en = 1;
        
        direction.d = direction.q;
        brick_level.d = brick_level.q;
        previous_state.d = bricky.q;

        bricky.TWO:
        case(direction.q) {
          0:
          if(brick_pos.q != hE000) {
            brick_pos.d = brick_pos.q << 1;
            led_ram.write_data = brick_pos.q << 1;
            led_ram.write_en = 1;
            direction.d = direction.q;
          }
          else {
            brick_pos.d = brick_pos.q;
            led_ram.write_data = brick_pos.q;
            led_ram.write_en = 1;
            direction.d = 1;
          }
          1:
          if(brick_pos.q != h0007) {
            brick_pos.d = brick_pos.q >> 1;
            led_ram.write_data = brick_pos.q >> 1;
            led_ram.write_en = 1;
            direction.d = direction.q;
          }
          else {
            brick_pos.d = brick_pos.q;
            led_ram.write_data = brick_pos.q;
            led_ram.write_en = 1;
            direction.d = 0;
          }
        }

        if(butt_edge.out) {
          bricky.d = bricky.FOUR;
        }
        bricky.d = bricky.THREE;
        brick_level.d = brick_level.q;
        previous_state.d = bricky.q;

        bricky.THREE:
        if(posClock.value == 1) {
          bricky.d = bricky.THREE;
        }
        else {
          bricky.d = bricky.ONE;
        }

        if(butt_edge.out) {
          bricky.d = bricky.FOUR;
        }
        direction.d = direction.q;
        brick_level.d = brick_level.q;
        previous_state.d = bricky.q;

        bricky.FOUR:
          if(brick_level.q != 12) {
            brick_level.d = brick_level.q + 3;
          }
          else {
            brick_level.d = 0;
          }

          bricky.d = previous_state.q;
          direction.d = direction.q;
          previous_state.d = bricky.q;
        }



      led_pattern[brick_level.q] = brick_pos.q;
      led_pattern[brick_level.q+1] = brick_pos.q;
      led_pattern[brick_level.q+2] = brick_pos.q;

      //led = direction.q;
      ledM.pattern[0] = led_ram.read_data;
      ledM.pattern[15:1] = led_pattern[15:1];

      // for (i = 0; i < 16; i++) {
      //   led_ram.address = i;
      //   ledM.pattern[i] = h0007;
      // }

    }
  }
