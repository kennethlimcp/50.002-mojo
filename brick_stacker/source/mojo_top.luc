module mojo_top (
  input clk,              // 50MHz clock
  input rst_n,            // reset button (active low)
  output led [8],         // 8 user controllable LEDs
  input cclk,             // configuration clock, AVR ready when high
  output spi_miso,        // AVR SPI MISO
  input spi_ss,           // AVR SPI Slave Select
  input spi_mosi,         // AVR SPI MOSI
  input spi_sck,          // AVR SPI Clock
  output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
  input avr_tx,           // AVR TX (FPGA RX)
  output avr_rx,          // AVR RX (FPGA TX)
  input avr_rx_busy,      // AVR RX buffer full
  output io_seg [8],      // 7-segment LEDs on IO Shield
  output io_sel [4],      // Digit select on IO Shield
  output a[16],
  output c[16],
  input button
  ) {

    alu16 alu;
    sig rst;              // reset signal
    sig led_pattern[16][16];  //sig to store led patterns for all 16 rows

    var i;

    .clk(clk) {
      // The reset conditioner is used to synchronize the reset signal to the FPGA
      // clock. This ensures the entire FPGA comes out of reset at the same time.
      reset_conditioner reset_cond;
      button_conditioner butt;
      edge_detector butt_edge(#RISE(0),#FALL(1));

      .rst(rst){
        led_matrix ledM;
        counter clocky(#SIZE(1),#DIV(16));  //must be the same as led_Matrix DIV
        dff brick_pos[16](#INIT(h0007));    //tracks position of brick
        dff direction[1](#INIT(0));         //sets direction to shift
        dff brick_level[4](#INIT(0));       //tells you which level is the brick moving on
        dff previous_state[3](#INIT(0));     //remembers the previous_state for button irq

        dff level_one[16](#INIT(h0007));    //stores level one brick pos
        dff level_two[16](#INIT(h0000));    //stores level two brick pos
        dff level_three[16](#INIT(h0000));  //stores level three brick pos
        dff level_four[16](#INIT(h0000));   //stores level four brick pos
        dff level_five[16](#INIT(h0000));   //stores level five brick pos
        dff score[12](#INIT(h000));         //store score for entire game

        fsm bricky (#INIT(SCREEN_REFRESH)) = {SCREEN_REFRESH, SHIFT_BRICK, DRAW_BRICK, NEXT_LEVEL, END};

        multi_seven_seg seg;
      }
    }

    .clk(clocky.value) {
      .rst(rst){
        counter posClock(#SIZE(1),#DIV(3));  //dividing the led scan clock by 2^3
      }
    }

    always {
      reset_cond.in = ~rst_n; // input raw inverted reset signal
      rst = reset_cond.out;   // conditioned reset

      spi_miso = bz;          // not using SPI
      spi_channel = bzzzz;    // not using flags
      avr_rx = bz;            // not using serial port

      led = h00;

      //seg.values = dec_ctr.digits;
      seg.values = {4h0,score.q[11:8],score.q[7:4],score.q[3:0]};
      io_seg = ~seg.seg; // connect segments to the driver
      io_sel = ~seg.sel; // connect digit select to the driver

      butt.in = button;
      butt_edge.in = butt.out;

	    alu.a = h00;
	    alu.b = h00;
	    alu.alufn = h00;

      a = ledM.a;             //set anode pins to output from ledM module
      c = ledM.c;             //set cathode pins to output from ledM module

      for (i = 0; i < led_pattern.WIDTH[0]; i++) {
        led_pattern[i] = h0000;
      }

      case(bricky.q) {
        bricky.SCREEN_REFRESH:
          if(posClock.value == 1) {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.SHIFT_BRICK;
          }
          else {
            brick_pos.d = brick_pos.q;
            bricky.d = bricky.SCREEN_REFRESH;
          }

          if(butt_edge.out) {
            bricky.d = bricky.NEXT_LEVEL;
          }

          direction.d = direction.q;
          brick_level.d = brick_level.q;
          previous_state.d = bricky.q;

        bricky.SHIFT_BRICK:
          case(direction.q) {
            0:
            if(brick_pos.q != hE000) {
              alu.a = brick_pos.q;
              alu.b = 1;
              alu.alufn = h20; //SHL
              brick_pos.d = alu.out;
              case(brick_level.q) {
                0:
                  level_one.d = alu.out;
                3:
                  level_two.d = alu.out;
                6:
                  level_three.d = alu.out;
                9:
                  level_four.d = alu.out;
                12:
                  level_five.d = alu.out;
              }
              direction.d = direction.q;


            }
            else {
              brick_pos.d = brick_pos.q;
              direction.d = 1;
            }
            1:
              if(brick_pos.q != h0007) {
                alu.a = brick_pos.q;
                alu.b = 1;
                alu.alufn = h21; //SHR
                brick_pos.d = alu.out;
                case(brick_level.q) {
                  0:
                    level_one.d = alu.out;
                  3:
                    level_two.d = alu.out;
                  6:
                    level_three.d = alu.out;
                  9:
                    level_four.d = alu.out;
                  12:
                    level_five.d = alu.out;
                }
                direction.d = direction.q;
              }
              else {
                brick_pos.d = brick_pos.q;
                direction.d = 0;
              }
          }

          if(butt_edge.out) {
            bricky.d = bricky.NEXT_LEVEL;
          }
          bricky.d = bricky.DRAW_BRICK;
          brick_level.d = brick_level.q;
          previous_state.d = bricky.q;

        bricky.DRAW_BRICK:
          if(posClock.value == 1) {
            bricky.d = bricky.DRAW_BRICK;
          }
          else {
            bricky.d = bricky.SCREEN_REFRESH;
          }

          if(butt_edge.out) {
            bricky.d = bricky.NEXT_LEVEL;
          }
          direction.d = direction.q;
          brick_level.d = brick_level.q;
          previous_state.d = bricky.q;

        bricky.NEXT_LEVEL:
          if(brick_level.q != 12) {
            alu.a = brick_level.q;
            alu.b = 3;
            alu.alufn = h00;  //ADD
            brick_level.d = alu.out;
            bricky.d = previous_state.q;
            score.d = score.q + 1;
          }
          else {
            bricky.d = bricky.END;
          }

          direction.d = direction.q;
          previous_state.d = bricky.q;

        bricky.END:
          bricky.d = bricky.END;
      }

      led_pattern[brick_level.q] = brick_pos.q;
      led_pattern[brick_level.q+1] = brick_pos.q;
      led_pattern[brick_level.q+2] = brick_pos.q;
      led_pattern[0] = level_one.q;
      led_pattern[1] = level_one.q;
      led_pattern[2] = level_one.q;
      led_pattern[3] = level_two.q;
      led_pattern[4] = level_two.q;
      led_pattern[5] = level_two.q;
      led_pattern[6] = level_three.q;
      led_pattern[7] = level_three.q;
      led_pattern[8] = level_three.q;
      led_pattern[9] = level_four.q;
      led_pattern[10] = level_four.q;
      led_pattern[11] = level_four.q;
      led_pattern[12] = level_five.q;
      led_pattern[13] = level_five.q;
      led_pattern[14] = level_five.q;

      ledM.pattern[15:0] = led_pattern[15:0];
      led = score.q;
     }
  }
